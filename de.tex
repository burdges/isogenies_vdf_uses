\documentclass{llncs}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
	unicode=true,
	colorlinks=true,
	citecolor=blue!70!black,
	filecolor=black,
	linkcolor=red!70!black,
	urlcolor=blue,
	pdfstartview={FitH},
}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\renewcommand{\O}{\mathcal{O}}
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\polylog}{polylog}
\DeclareMathOperator{\Setup}{\mathsf{Setup}}
\DeclareMathOperator{\TSetup}{\mathsf{TrustedSetup}}
\DeclareMathOperator{\Extract}{\mathsf{Extract}}
\DeclareMathOperator{\Encaps}{\mathsf{Encaps}}
\DeclareMathOperator{\Decaps}{\mathsf{Decaps}}
\newcommand{\pp}{\mathsf{pp}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\idk}{\mathsf{idk}}
\newcommand{\keyspace}{\mathcal{K}}
\newcommand{\cipherspace}{\mathcal{C}}
\newcommand{\Emid}{E_\mathrm{mid}}
\newcommand{\Qmid}{Q_\mathrm{mid}}

\title{Delay Encryption}
% \author{Jeffrey Burdges\inst{1}
%   \and
%   Luca De Feo\inst{2}\orcidID{0000-0002-9321-0773}}
% \institute{
%   Web 3, Switzerland
%   \and
%   IBM Research ZÃ¼rich, Switzerland
% }

\begin{document}

\maketitle

\begin{abstract}
  We introduce a new primitive named Delay Encryption, and give an
  efficient instantation based on isogenies of supersingular curves
  and pairings. %
  Delay Encryption is related to Time-lock Puzzles and Verifiable
  Delay Functions, and can be roughly described as ``identity based
  encryption with slow derived private key issuance''. %
  It has several applications in distributed protocols, such as
  sealed bid Vickrey auctions and electronic voting.

  We give an instantiation of Delay Encryption by modifying Boneh and
  Frankiln's IBE scheme, where we replace the master secret key by a
  long chain of isognies, as in the isogeny VDF of De Feo, Masson, 
  Petit and Sanso. %
  Similarly to the isogeny-based VDF, our Delay Encryption requires a
  trusted setup before parameters can be safely used; our trusted
  setup is identical to that of the VDF, thus the same parameters can
  be generated once and shared for many executions of both protocols,
  with possibly different delay parameters.

  We also discuss several topics around delay protocols
  based on isogenies that were left untreated by De Feo \emph{et al.},
  namely: distributed trusted setup, watermarking, and implementations
  issues.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

The first appearance of \emph{delay cryptography} was in Rivest,
Shamir and Wagner's~\cite{TLP} \emph{Time-lock Puzzle}, an encryption
primitive where the holder of a trapdoor can encrypt (or decrypt)
``fast'', but where anyone not knowing the trapdoor can only decrypt
(or encrypt) ``slowly''.

Recently, a revival of delay cryptography has been promoted by
research on blockchains, in particular to the introduction of
\emph{Verifiable Delay Functions (VDF)}~\cite{Boneh}, deterministic
functions $f$ that can only be evaluated  ``sequentially'' and ``slowly'',
but such that verifying that $y=f(x)$ is ``fast''. %

After their definition, VDFs quickly gained attention, prompting two
independent solutions in the space of a few
weeks~\cite{Wesolowski,Pietrzak}. %
Both proposals are based on repeated squaring in groups of known
order, and are similar in spirit to Rivest \emph{et al.}'s time-lock
puzzle, however they use no trapdoor.

One year later, another VDF, based on a different algebraic structure,
was proposed by De Feo, Masson, Petit and
Sanso~\cite{10.1007/978-3-030-34578-5_10}. %
This VDF uses chains of supersingular isogenies as ``sequential slow''
functions, and pairings for efficient verification.

In this work we introduce a new delay primitive, called Delay
Encryption. %
It is related to both Time-lock puzzles and VDFs, however it does not
seem to be subsumed by either. %
We also give an instantiation of Delay Encryption based on the same
isogenies/pairings framework of De Feo \emph{et al.}.

Delay Encryption can be roughly described as Identity Based Encryption
(IBE) with ``sequential and slow'' derived private key issuance. %
Recall that an IBE scheme is a public key encryption with three
parties: a dealer who possess a master private-public key-pair, a
receiver who has an \emph{identity} that acts as its public key (e.g.,
its email address), and a senders who wants to send a message to the
receiver. %
In IBE, receivers get their private keys from the dealer, who computes
the private key associated to an identity using its master secret key;
senders encrypt messages to the receivers using both the master public
key and the identity of the receiver; receivers decrypt using the
master public key and their private key.

In Delay Encryption there are no secrets. %
Receivers become \emph{sessions}, with an associated \emph{session
  identifier}; it is important that session identifiers are
unpredictable, and are thrown away after the first use. %
The dealer is replaced by a public functionality, that takes as input
a session identifier and outputs a \emph{session key}; this
functionality, named \emph{extraction}, is guaranteed to be
``sequential and slow''. %
Senders encrypt messages to the sessions by using the public
parameters, and the identifier of the session. %
After extraction produces its output, everyone can decrypt messages
sent to the session using the session key.

Delay Encryption is different from Time-lock puzzles in that it has no
trapdoor, and from VDFs in that it provides a ``fast'' computation,
rather than just a ``fast'' verification. %
Although some applications of Delay Encryption may be also achieved
less efficiently through VDFs or Time-locks, it does not seem easy to
generically construct Delay Encryption from either.


\subsection{Applications of Delay Encryption}

Delay Encryption has some intersting applications, of which we mention
two.

\paragraph{Vickrey auctions.} Sealed bid auctions are easily
implemented using standard public key encryption: each bidder seals
its bid by encrypting it under a random public key; when the auction
is over it publishes the secret key to reveal the bid.

This design has one flaw in contexts where it is required that all
bidders reveal their bids at the end of the auction. %
For example, in Vickrey auctions, the highest bidder wins the auction,
but only pays the price of the second highest bid. %
If at the end of the auction some bidders refuse to reveal their bid,
the result of the auction may be invalid.

This problem is difficult to solve using standard public key
cryptography, as it obviously requires some form of key escrow. %
Delay Encryption provides a very natural solution: at the beginning of
the auction an \emph{auction id} is selected using some unpredictable
and unbiased randomness, e.g., coming from a randomness beacon. %
After the auction id is published, all bidders encrypt to the auction
as senders of a Delay Encryption scheme. %
In the meantime, anyone can start computing the auction key using the
extraction functionality. %
When the \emph{auction key} associated with the auction id is known,
anyone can decrypt all bids and check the winner.

\paragraph{Electronic voting.} In electronic voting it is often
required that the partial tally of an election stays unknown until the
end, to avoid influencing the outcome. %

Delay Encryption again solves the problem elegantly: once the
\emph{election id} is published, all voters can cast their ballot by
encrypting under it. %
Only after the election key is published, anyone can verify the
outcome by decrypting the ballots. %

Of course this idea can be combined with classical techniques for
anonymity, integrity, etc.

\medskip

In both applications it is evident that the session/auction/election
id must be unpredictable and unbiased: if it is not, someone may start
computing the session key before anyone else can, and thus break the
delay property. %
Fortunately, this requirement is easily satisfied by using randomness
beacons, which accessorily can be implemented using VDFs.

\subsubsection{Plan.}
We start by defining Delay Encryption in
Section~\ref{sec:definitions}, and give our instantiation in
Section~\ref{sec:delay-encrypt-from}. %
In the following sections, we discuss several topics related to both
Delay Encryption and VDFs from isogenies and pairings:
Section~\ref{sec:distr-trust-setup} explains how to efficiently
implement the trusted setup, common to both our Delay encryption and
the isogeny based VDF, in a distributed manner;
Section~\ref{sec:watermarking} covers Watermarking, a mechanism to
prove ``ownership'' of a ``slow'' computation; finally
Section~\ref{sec:secure-impl-isog} discusses implementation details
and challenges for isogeny based delay functions.


\section{Definitions}
\label{sec:definitions}

Our definition of Delay Encryption uses an API similar to a Key
Encapsulation Mechanism; the adaptation to a PKE-like API is
straightforward. A Delay Encryption scheme consists of four
algorithms: $\Setup$, $\Extract$, $\Encaps$ and $\Decaps$:

\begin{description}
\item[$\Setup(\lambda, T) \to \pp$.] %
  Takes a \emph{security parameter} $\lambda$, a \emph{delay
    parameter} $T$, and produces a set of public parameters $\pp$. %
  $\Setup$ must run in time $\poly(\lambda,T)$.
\item[$\Extract(\pp,\id) \to \idk$.] %
  Takes the public parameters $\pp$ and a \emph{session identifier}
  $\id\in\{0,1\}^*$, and outputs a \emph{session key} $\idk$. %
  $\Extract$ is expected to run in time \emph{exactly} $T$, see below.
\item[$\Encaps(\pp,\id)\to (c,k)$.] %
  Takes the public parameters $\pp$ and a \emph{session identifier}
  $\id\in\{0,1\}^*$, and outputs a \emph{ciphertext}
  $c\in\cipherspace$ and a \emph{key} $k\in\keyspace$. %
  $\Encaps$ must run in time $\poly(\lambda)$.
\item[$\Decaps(\pp,\id,\idk,c)\to k$.] %
  Takes the public parameters $\pp$, a \emph{session identifier}
  $\id$, a \emph{session key} $\idk$, a ciphertext $c\in\cipherspace$,
  and outputs key $k\in\keyspace$. %
  $\Decaps$ must run in time $\poly(\lambda)$.
\end{description}

A Delay Encryption scheme is correct if
\[\bigl(c,\Decaps(\pp,\id,\idk,c)\bigr) = \Encaps(\pp,\id),\]
whenever $\idk=\Extract(\pp,\id)$. %
The security of Delay Encryption is defined similarly to that of
public key encryption schemes, and in particular of identity-based
ones; however one additional property is required of $\Extract$: that
for a randomly selected identifier $\id$, the probability that
$\Extract$ outputs $\idk$ in time less than $T$ is negligible. %
We now give the formal definition.

\paragraph{The security game.} It is apparent from the definitions
that Delay Encryption has no secrets: after public parameters $\pp$
are generated, anyone can run any of the algorithms. %
Thus, the usual notion of indistinguishability will only be defined
with respect to the delay parameter $T$: no adversary is able to
distinguish a key $k$ from a random string in time $T-o(t)$, but
anyone can in time $T$. %
Properly defining what is meant by ``time'' requires fixing a
computation model. %
Here we follow the usual convention from VDFs, and assume a model of
parallel computation: in this context, ``time $T$'' may mean $T$ steps
of a parallel Turing machine, or an arithmetic circuit of depth $T$. %
Crucially, we do not bound the amount of parallelism of the Turing
machine, or the breadth of the circuit, i.e., we focus on
\emph{sequential delay} functions.

We consider the following $\Delta$-IND-CCA game. %
Note that the game involves no oracles, owing to the fact that the
scheme has no secrets. %
%
\begin{description}
\item[Precomputation.] The adversary receives $\pp$ as input, and
  outputs an algorithm $\mathcal{D}$. %
\item[Challenge.] The challenger selects a random $\id$ and computes
  $(c,k_0)\gets\Encaps(\pp,\id)$. %
  It then picks a uniformly random $k_1\in\keyspace$, and a random bit
  $b\in\{0,1\}$. %
  Finally, it outputs $(c,k_b)$.
\item[Guess.] The algorithm $\mathcal{D}$ is run on input
  $(c,k_b)$. %
  The adversary wins if $\mathcal{D}$ terminates in time less than
  $\Delta$, and the output is such that $\mathcal{D}(c,k_b) = b$.
\end{description}

We stress that the game is intrinsically non-adaptive, in the sense
that no computation is ``free'' after the adversary has seen the
challenge.

We say a Delay Encryption scheme is \emph{$\Delta$-Delay
  Indistinguishable under Chosen Ciphertext Attacks} if, for any
efficient adversary running the precomputation in time
$\poly(\lambda,T)$, the probability of winning the game is
negligible. %
Obviously, the interesting schemes are those where $\Delta = T-o(T)$.


\section{Delay Encryption from isogenies and pairings}
\label{sec:delay-encrypt-from}

We instantiate Delay Encryption from the same framework De Feo,
Masson, Petit and Sanso used to instantiate Verifiable Delay
Functions~\cite{10.1007/978-3-030-34578-5_10}. %
We briefly recall it here for completeness.

An elliptic curve $E$ over a finite field $\F_{p^n}$ is said to be
supersingular if the trace of its Frobenius endomorphism is divisible
by $p$, i.e., if $\#E(\F_{p^n})=1\mod p$. %
Over the algebraic closure of $\F_p$, there is only a finite number of
isomorphism classes of supersingular curves, and every class contains
a curve defined over $\F_{p^2}$.

An isogeny is a group morphism of elliptic curves with finite
kernel. %
In particular, isogenies preserve the group order of elliptic curves,
and thus they preserve supersingularity. %
Isogenies can be represented by ratios of polynomials, and, like
polynomials, have a \emph{degree}. %
Isogenies of degree $\ell$ are also called $\ell$-isogenies; the
degree is multiplicative with respect to composition, thus
$\deg\phi\circ\psi=\deg\phi\cdot\deg\psi$. %
The degree is an important invariant of isogenies, roughly measuring
the amount of information needed to represent them.

An isogeny graph is a graph whose vertices are isomorphism classes of
elliptic curves, and whose edges are isogenies, under some
restrictions. %
Isogeny-based cryptography mainly uses two types of isogeny graphs:
\begin{itemize}
\item The \emph{full supersingular graph} of $\F_p$, whose vertices
  are all isomorphism classes of supersingular curves over $\F_{p^2}$,
  and whose edges are all isogenies of a prime degree $\ell$;
  typically $\ell=2,3$.
\item The \emph{$\F_p$-restricted supersingular graph}, or
  \emph{supersingular CM graph} of $\F_p$, whose vertices are all
  $\F_p$-isomorphism classes of supersingular curves over $\F_p$, and
  whose edges are $\ell$-isogenies for all primes $\ell$ up to some
  bound; typically $\ell\lessapprox\lambda\log\lambda$, where
  $\lambda$ is the security parameter.
\end{itemize}

Any $\ell$-isogeny $\phi:E\to E'$ has a unique \emph{dual}
$\ell$-isogeny $\hat\phi:E'\to E$ such that
\begin{equation}
  \label{eq:adjoin}
  e_N(\phi(P),Q) = e_N'(P,\hat\phi(Q)),
\end{equation}
for any integer $N$ and any points $P\in E[N]$, $Q\in E'[N]$, where
$e$ is the Weil pairing on $E$, and $e'$ the one on $E'$. %
The same equation, with the same $\hat\phi$, also holds for any other
known pairing, such as the Tate and Ate pairings.

The framework of De Feo \emph{et al.} uses chains of small degree
isogenies as delay functions, and the pairing
equation~\eqref{eq:adjoin} as an efficient means to verify the
computation. %
Formally, they propose two related instantiations of VDF, following
the same pattern:
%
\begin{description}
\item[Trusted setup] takes as input a security parameter $\lambda$,
  and produces a prime $N\approx 2^{2\lambda}$, a prime $p=N\cdot f+1$
  for some cofactor $f\sim 2^{\lambda^3}$, and a random supersingular
  elliptic curve $E$ over $\F_p$.
\item[Setup] takes as input $p,N,E$, a delay parameter $T$, and
  performs a walk in an $\ell$-isogeny graph to produce a degree
  $\ell^T$ isogeny $\phi:E\to E'$.
  
  It also computes a point $P\in E$ of order $N$, and outputs
  $P,\phi(P)$.
\item[Evaluation] takes as input a random point $Q\in E'[N]$ and outputs
  $\hat\phi(Q)$.
\item[Verification] uses Eq.~\eqref{eq:adjoin} to check that the value
  output by evaluation is $\hat\phi(Q)$ as claimed.
\end{description}

The two variants only differ in the way the isogeny walk is set up,
and in minor details of the verification; these differences will be
irrelevant to us.

The delay property of this VDF rests, roughly speaking, on the
assumption that a chain of $T$ isogenies of small prime degree $\ell$
cannot be computed more efficiently than by going through each of the
isogenies one at a time, sequentially. %
The case $\ell=2$ is very similar to repeated squaring in groups of
unknown order as used by other VDFs~\cite{Wesolowski,Pietrzak} and
time-lock puzzles~\cite{TLP}: in the latter one iterates $T$ times the
function $x\mapsto x^2$, a polynomial of degree $2$; in the former one
iterates rational fractions of degree $2$. %
See Section~\ref{sec:secure-impl-isog} for more details.

It is important to remark that both setup and evaluation in these VDFs
are ``slow'' algorithms, indeed both need to evaluate an isogeny chain
(either $\phi$, or $\hat\phi$) at one input point of order $N$; this
is in stark contrast with VDFs based on groups of unknown order, where
the complexity of setup does not depend on the delay parameter $T$.


\subsection{Instantiation}

The isogeny-based VDF of De Feo \emph{et al.}\ can be understood as a
modification on the Boneh--Lynn--Shacham~\cite{boneh+lynn+shacham04}
signature scheme, where the secret key is replaced by a long chain of
isogenies: signing becomes a ``slow'' operation and thus realizes the
evaluation function, whereas verification stays efficient.

Similarly, we obtain a Delay Encryption scheme by modifying the IBE
scheme of Boneh and Franklin~\cite{10.1007/3-540-44647-8_13}: the
master secret is replaced by a long chain of isogenies, while session
identifiers play the role of identities, so that producing the
decryption key for a given identity becomes a slow operation.

Concretely, $\Setup$ is identical to that of the VDF: it is split in a
trusted and an untrusted part, the former being independent of the
delay parameter $T$, and reusable for arbitrarily many untrusted
setups.

\begin{description}
\item[$\TSetup(\lambda)$.]\
  \begin{enumerate}
  \item Generate primes $N$ and $p=4\cdot N\cdot f - 1$, such that
    discrete logarithms in the subgroup of order $N$ of $\F_{p^2}$ are
    $\lambda$-hard;
  \item Generate a nearly uniformly random supersingular curve
    $E/\F_p$ by starting from the curve $y^2=x^3+x$ and performing a
    random walk in the $\F_p$-restricted supersingular graph;
  \item Output $N,p,E$.
  \end{enumerate}
\item[$\Setup(N,p,E,T)$.]\
  \begin{enumerate}
  \item Perform an $\ell$-isogeny walk $\phi:E\to E'$ of length $T$;
  \item Select a random point $P\in E(\F_p)$ of order $N$, and compute
    $\phi(P)$;
  \item Output $E',\phi,P,\phi(P)$.
  \end{enumerate}
\end{description}

The isogeny chain $\phi$ in $\Setup$ can be generated by any of the
two methods proposed by De Feo \emph{et al.}, the difference will be
immaterial for Delay Encryption; as discussed
in~\cite{10.1007/978-3-030-34578-5_10}, a (deterministic) walk limited
to curves and isogenies defined over $\F_p$ will be more efficient,
however a generic (pseudorandom) walk over $\F_{p^2}$ will offer some
partial protection against quantum attacks.

Before defining the other routines, we need two hash functions. %
The first, $H_1:\{0,1\}*\to E'[N]$, will be used to hash session
identifiers to points of order $N$ in $E'/\F_{p^2}$ (although the
curve $E'$ may be defined over $\F_p$). %
The second, $H_2:F_{p^2}\to\{0,1\}^\lambda$, will be a key derivation
function. %
Let $\pp = (N,p,E,E')$, then we define:

\begin{description}
\item[$\Extract(\pp,\phi,\id)$.]\
  \begin{enumerate}
  \item Let $Q = H_1(\id)$;
  \item Output $\hat\phi(Q)$.
  \end{enumerate}
\item[$\Encaps(\pp,P,\phi(P),\id)$.]\
  \begin{enumerate}
  \item Select a uniformly random $r\in\Z/N\Z$;
  \item Let $Q = H_1(\id)$;
  \item Let $k=e_N'(\phi(P),Q)^r$;
  \item Output $(rP,H_2(k))$.
  \end{enumerate}
\item[$\Decaps(\pp,\hat\phi(Q),rP)$.]\
  \begin{enumerate}
  \item Let $k = e_N(rP,\hat\phi(Q))$.
  \item Output $H_2(k)$.
  \end{enumerate}
\end{description}

Correctness of the scheme follows immediately from
Eq.~\eqref{eq:adjoin} and the bilinearity of the pairing. %

\begin{remark}
  Notice that two hashed identities $Q,Q'$ such that
  $Q-Q'\in \langle P\rangle$ are equivalent for encapsulation and
  decapsulation purposes, and thus an adversary only needs to compute
  the image of one of them under $\hat\phi$. %
  However, thanks to $H_1$, the probability of two identities
  colliding remains negligible (about $1/N$).
  
  Alternatively, if $E'$ is defined over $\F_p$, one can restrict the
  image of $H_1$ to the subgroup of $E'[N]$ annihilated by $\pi+1$,
  where $\pi$ is the Frobenius endomorphsim, like
  in~\cite{10.1007/978-3-030-34578-5_10}.
\end{remark}


\subsection{Security}

The standard security hypothesis for isogeny-based delay schemes is
the $\Delta$-hardness of the \emph{isogeny shortcut
  game}~\cite{10.1007/978-3-030-34578-5_10}:

\begin{description}
\item[Precomputation.] The adversary receives $N,p,E,E',\phi$, and
  outputs an algorithm $\mathcal{S}$ (in time $\poly(\lambda,T)$).
\item[Challenge.] The challenger outputs a uniformly random
  $Q\in E'[N]$.
\item[Guess.] The algorithm $\mathcal{S}$ is run on input $Q$. The
  adversary wins if $\mathcal{S}$ terminates in time less than
  $\Delta$, and $\mathcal{S}(Q) = \hat\phi(Q)$.
\end{description}

Unfortunately, it seems challenging to reduce $\Delta$-IND-CCA
security of our Delay Encryption scheme to some $\Delta'$-hardness of
an isogeny shortcut game. %
Indeed, even given a more powerful adversary that is able to correctly
compute $k=e_N(rP,\hat\phi(Q))$ in time $\Delta$ from the knowledge or
$Q$ and $rP$, it is not clear how to efficiently extract the value of
$\hat\phi(Q)$ from $k$, as this would amount to efficiently solving a
pairing inversion problem.

It is clear that the isogeny shortcut models a weaker notion of
security for Delay Encryption, one that states that it is hard to
produce the output of $\Extract$ in time less than $\Delta$, however
this is obviously insufficient to guarantee $\Delta'$-IND-CCA, as an
alternative way to compute the key $k$ is to evaluate $\phi(rP)$ and
compute $k=e_N'(\phi(rP), Q)$. %
In practice, computing $\phi(rP)$ is expected to be at least as
``slow'' as computing $\hat\phi(Q)$, however this idea is not captured
by the isogeny shortcut game; and, even then, that would not exclude
other ways to win the $\Delta$-IND-CCA game, without the ability to
extract $\phi(rP)$ or $\hat\phi(Q)$ from a successful adversary.

Replacing the isogeny shortcut game with a decision problem would not
help either, owing to the usual obstacle of decision problems being
easy for pairings; indeed, the decision version of the shortcut game
is easily decided by the verification procedure of the VDF mentioned
above.

Faced with this difficulty, we simply chose to not provide a security
proof, and leave the search for meaningful security reductions for
future work.

\subsubsection{Attacks.} We now shift our attention to attacks. %
As discussed in~\cite{10.1007/978-3-030-34578-5_10}, there are three
types of known attacks: \emph{shortcut} attacks, discrete logarithm
attacks, and attacks on the computation.

Parameters for a Delay Encryption scheme must be chosen so that all
known attacks have exponential difficulty in the security parameter
$\lambda$. %
Given that (total) attacks successfully compute decapsulation in
exponential time in $\lambda$, it is evident that the delay parameter
$T$ must grow at most subexponentially in $\lambda$.

\paragraph{Shortcut attacks} aim at computing a shorter path
$\psi:E\to E'$ in the isogeny graph from the knowledge of
$\phi:E\to E'$. %
The name should not be confused with the isogeny shortcut game
described above, as shortcut attacks are only one of the possible ways
to beat the game.

De Feo \emph{et al.}\ show that shortcut attacks are possible when the
endomorphism ring of at least one of $E$ or $E'$ is known. %
Indeed, in this case, the isogeny $\phi$ can be translated to an ideal
class in the endomorphism ring, then smoothing techniques similar
to~\cite{kohel2014quaternion} let us convert the ideal to one of
smaller norm, and finally to an isogeny $\phi:E\to E'$ of smaller
degree.

The only way out of these attacks is to select the starting curve $E$
as a uniformly random supersingular curve over $\F_p$, then no
efficient algorithm is known to compute $\End(E)$, nor $\End(E')$. %
Unfortunately, the only way we currently know to sample nearly
uniformly in the supersingular class over $\F_p$, is to
(paraphrasing) choose the endomorphism ring first, and then compute
$E$ given $\End(E)$.

Thus, the solution put forth in~\cite{10.1007/978-3-030-34578-5_10} is
to generate the starting curve $E$ via a trusted setup, that first
selects $\End(E)$, and then outputs $E$ and throws away the
information about its endomorphism ring. %
We stress that, given a random supersingular curve $E$, computing
$\End(E)$ is a well known hard problem, upon which almost most of
isogeny-based cryptography is founded. %
We explain in the next section how to mitigate the inconvenience of
having a trusted setup, using a distributed protocol.

As stressed in~\cite{10.1007/978-3-030-34578-5_10}, there is no
evidence that ``hashing'' in the supersingular class, i.e., sampling
nearly uniformly without gaining knowledge of the endomorphism ring,
should be a hard problem. %
But there is no evidence it should be easy either, and several
attempts have failed
already~\cite{cryptoeprint:2019:1202,love2019supersingular}.

Another possibility hinted at in~\cite{10.1007/978-3-030-34578-5_10}
would be to generate ordinary pairing friendly curves with large
isogeny class, as the shortcut attack is then thwarted by the
difficulty of computing the order of the class group of the
endomorphism ring. %
However this possibly seems an even harder problem than hashing to the
supersingular class.

\paragraph{Discrete logarithm attacks} compute $\hat\phi(Q)$ by
directly solving the pairing equation~\eqref{eq:adjoin}. %
In our case, we can even directly attack the key encapsulation. %
Indeed, knowing $rP$, we obtain $r$ through a discrete logarithm, and
then compute $k=e_N'(\phi(P),Q)^r$.

Thanks to the efficiently computable pairing, the discrete logarithm
can actually be solved in $\F_{p^2}$, which motivates taking $p,N$
large enough to resist discrete logarithm computations. %
Obviously, this also shows that our scheme is easily broken by quantum
computers. %
See~\cite{10.1007/978-3-030-34578-5_10}, however, for a discussion of
how a setup with pseudo-random walks over $\F_{p^2}$ resists quantum
attacks in a world where quantum computers are available, but much
more expensive than classical ones.

\paragraph{Attacks on the computation} do not seek to deviate from the
description of the protocol, but simply try to speed up $\Extract$
beyond the way officially prescribed by the scheme. %
In this sort of attacks, the adversary may be given more resources
than the legitimate user: for example, it may be allowed a very large
precomputation, or it may dispose of an unbounded amount of
parallelism, or it may have access to an architecture not available to
the user (e.g., a quantum computer).

These attacks are the most challenging to analyze, because standard
complexity-theoretical techniques are of little help here. %
% (see, however~\cite{todo})
On some level, this goal is unachievable: given a sufficiently
abstract computational model, and a sufficiently powerful adversary,
any scheme is broken. %
For example, an adversary may precompute all possible pairs
$(Q,\hat\phi(Q))$ and store them in a $O(1)$-accessible RAM, then
extraction amounts to a table lookup. %
However, such an adversary with exponential precomputation,
exponential storage, and constant time RAM is easily dismissed as
unreasonable. %
More subtle trade-offs between precomputation, storage and efficiency
can be obtained, like, for example, RNS-based techniques to attack
group-based VDFs~\cite{BernsteinSorenson07}, although the real impact
of these theoretical algorithms has yet to be determined.

In practice, a pragmatic approach to address attacks on the
computation is to massively invest in highly specialized hardware
development to evaluate the ``sequential and slow'' function quickly,
and then produce the best designs at scale, so that they are available
to anyone who wants to run the extraction. %
This is the philosophy of the competitions organized by
Ethereum~\cite{ethereum-vdf} and Chia~\cite{chia-vdf}, targeting,
respectively, the RSA based VDF and the class group based VDF.

We explore this topic more in detail in
Section~\ref{sec:secure-impl-isog}.


\section{Distributed trusted setup}
\label{sec:distr-trust-setup}

Trusted setup is an obvious annoyance to distributed protocols. %
A way to mitigate this negative impact is to distribute trust over
several participants, ensuring through a multi-party computation that,
if at least one participant is honest, then the setup can be trusted.

Ethereum is notoriously investing in the RSA-based VDF with
Wesolowski's proof~\cite{ethereum-vdf,Wesolowski}, which is known to
require a trusted setup. %
To generate parameters, the Ethereum network will need to run a
distributed RSA modulus generation, for which all available techniques
essentially trace back to the work of Boneh and
Franklin~\cite{10.1007/BFb0052253}.

Distributed RSA modulus generation is notoriously a difficult task:
the cost is relatively high, and scales badly with the number of
participants. %
Worse still, specialized hardware for the delay function must be
designed specifically for the generated modulus, which means that
little design can be done prior to the distributed generation, and
that if the distributed generation is then found to be rigged, a new
round of distributed-generation-then-design is needed.

On the contrary, distributed parameter generation for our Delay
Encryption candidate, or for the isogeny based VDF, is extremely
easy. %
The participants start from a well known supersingular curve with
known endomorphism ring, e.g., $E_0\,:\,y^2=x^3-x$, and repeat, each
at its own turn, the following steps:
\begin{enumerate}
\item Participant $i$ checks all zero-knowledge proofs published by
  participants that preceded them;
\item They perform a pseudorandom $\psi_i:E_{i-1}\to E_i$
  walk of length $c\log(p)$ in the $\F_p$-restricted supersingular
  graph;
\item They publish $E_i$, and a zero-knowledge proof that they know an
  isogeny $\psi:E_{i-1}\to E_i$.
\end{enumerate}

The constant $c$ is to be determined as a function of the expansion
properties of the isogeny graph, and is meant to be large enough to
ensure nearly uniform mixing of the walk. %
In practice, this constant is usually small, say $c<10$, implying that
each participant needs to evaluate a few thousands isogenies, a
computation that is expected to take in the order of
seconds~\cite{10.1007/978-3-030-03332-3_15}.

The setup is clearly secure as long as at least one participant is
honest. %
Indeed it is well known that computing a path from $E_i$ to $E_0$ is
equivalent to computing the endomorphism ring of
$E_i$~\cite{kohel2014quaternion,10.1007/978-3-319-78372-7_11}, and,
since $E_i$ is nearly uniformly random in the supersingular graph, the
dishonest participants have no advantage in solving this problem
compared to a generic attacker.

This distributed computation scales linearly with the number of
participants, each participant needing to check the proofs of the
previous ones. %
It can be left running for a long period of time, allowing many
participants to contribute trust without any need for prior
registration. %
More importantly, it is \emph{updatable}, meaning that after the
distributed generation is complete, the final curve $E$ can be used as
the starting point for a new distributed trusted setup. %
This way the trusted setup can be updated regularly, building upon the
trust accumulated in previous distributed generations.

Compared with the trusted setup for RSA, the outcome of the setup is
much less critical for the design of hardware. %
Indeed, the primes $p,N$ can be publicly chosen in advance, and
hardware can be designed for them before the trusted setup is
performed. %
The trusted curve $E$ only impacts the first few steps of the ``slow''
isogeny walk $\phi:E\to E'$ generated by the untrusted setup, and can
easily be integrated in the hardware design at a later stage.

\smallskip

Ignoring zero-knowledge temporarily, Eq.~\eqref{eq:adjoin} already
provides a proof of knowledge of an isogeny $\psi_i:E_{i-1} \to E_i$,
and implicitly of its dual $\hat\psi_i: E_i \to E_{i-1}$.  
We can instantiate this proof as follows:
\begin{enumerate}
\item Hash the curves $E_{i-1},E_i$ to a pair of points
  $P\in E_{i-1}[(N,\pi-1)]$, $Q\in E_i[(N,\pi+1)]$;
\item Publish $\psi_i(P), \hat\psi_i(Q)$.
\end{enumerate}
Then verification consists of simply:
\begin{enumerate}
\item Compute $P,Q\gets H_1(E_{i-1},E_i)$,
 % with $P \in E_{i-1}[(N,\pi+1)]$ and $Q\in E_i[(N,\pi-1)]$,
\item Check that $\psi_i(P)\in E_i[(N,\pi-1)]$ and
  $\hat\psi_i(Q)\in E_{i-1}[(N,\pi+1)]$;
\item Check that
  $e_N^i(\psi_i(P),Q) = e_N^{i-1}(P,\hat\psi_{i-1}(Q))$.
\end{enumerate}

This proof is compact, requiring only two elements of $\F_p$, and
efficient because computing $\psi_i(P),\hat\psi_i(Q)$ only adds a
small overhead to the computation of $\psi_i$, and verification takes
essentially two pairing computations. %
It is not however zero-knowledge because $\psi_i(P)$ and
$\hat\psi_i(Q)$, and even the pairing values, leak some information on
$\psi_i$, and thus the security of the trusted setup stands on a less
firm ground.

We make this zero-knowledge easily enough however: 
we need two additional independent points
$P',Q' \gets H_2(E_{i-1},E_i)$ with
 $P' \in E_i[(N,\pi-1)]$ and $Q' \in E_{i-1}[(N,\pi+1)]$,
we now publish only Pedersen commitments 
 $X = x P' + \psi_i(P) \in E_i[(N,\pi-1)]$ and
 $Y = y Q' + \hat\psi_i(Q) \in E_{i-1}[(N,\pi+1)]$
 with $x,y$ secret and random,
along with a proof-of-knowledge for $(x,y)$ such that 
  $$ e_N^i(X,Q) e_N^{i-1}(P,Q')^y  = e_N^{i-1}(P,Y) e_N^i(P',Q)^x . $$
In this, verifiers check that $X \ne P'$ and $Y \ne Q'$,
along with verifying the prove-of-knowledge.
We can even take $x=y$ at which point our proof simplifies slightly
to be merely a Schnorr signature in the target group.
We ask verifiers to compute four parings, which only doubles
the verifier time.
% Also, four hash-to-curve operations, and 
% four-ish scalar multiplications in the target group.
% ($e_N^i(P',Q)$, $e_N^{i-1}(P,Q')$, $e_N^i(X,Q)$, $e_N^{i-1}(P,Y)$)

For completeness, we also mention some other tools with which one
might prove knowledge of this isogeny in zero knowledge, although none
seem to be competitive with the technique above.
 
First, there exists a rapidly expanding SNARK toolbox from which
one could preform $\F_p$ arithmetic inside the SNARK to check the
verification conditions 2 and 3 directly.  
As instantiating the delay function imposes restrictions on $p$,
one cannot necessarily select $p$ using the Cocks-Pinch method to
provide a pairing friendly elliptic curve with group order $p$, 
like in \cite{ZEXE}. % https://eprint.iacr.org/2018/962.pdf
There are optimisations for arithmetic in arbitrary $\F_p$ 
however, especially using polynomial commitments,
like in \cite{plookup}. % https://eprint.iacr.org/2020/315.pdf

Second, there are well known post-quantum isogenies based proofs:
\begin{description}
\item[SIDH-style proofs~\cite{defeo+jao+plut12}] %
  are very inconvenient, because they require primes of a specific
  form, and severely limit the length of pseudo-random walks. %
  On top of that, they are very inefficient, and do not have perfect
  zero-knowledge. %
\item[SeaSign-style proofs~\cite{10.1007/978-3-030-17659-4_26}] %
  have sizes in the hundred of kilobytes, and their generation and
  verification are extremely slow (dozens of hours). %
  Note that several of the optimizations used for signatures,
  including the class group order precomputation of
  CSI-FiSh~\cite{10.1007/978-3-030-34578-5_9}, are not available in
  this context. %
  More research on the optimization of SeaSign-style proofs for this
  specific context would be welcome.
\end{description}


\section{Watermarking}
\label{sec:watermarking}

A common requirement in cryptocurrencies is to be able to reward
participants who spend resources to compute the delay function, be it
in the context of a VDF or a Delay Encryption. %
Wesolowski~\cite{Wesolowski} introduced the concept of \emph{proof
  watermarking}, i.e., attaching the proof of a VDF evaluation to an
identity, so that the ownership of the proof cannot be usurped without
performing essentially the same work as evaluating the VDF normally.

In the context of isogeny based VDFs, or of extraction in Delay
Encryption, this is a meaningless concept, because there is simply no
proof to watermark. %
Nevertheless, it is possible to attach a watermark to the output of
the delay function, which gives evidence that the owner of the
watermark spent an amount of effort comparable to legitimately
computing the output. %
The idea is to publish a \emph{mid-point} update on the progress of
the evaluation, and attach this mid-point to the identity of the
evaluator.

Concretely, given parameters $\phi:E\to E'$ and $(P,\phi(P))$, the
isogeny walk is split into two halves of equal size
$\phi_1:E\to \Emid$ and $\phi_2:\Emid\to E'$ so that
$\phi=\phi_2\circ\phi_1$, and $\phi_1(P)$ is added to the public parameters. %
Each evaluator then generates a secret key $s\in\Z/N\Z$ and a public
key $s\phi_1(P)$. %
When evaluating $\hat\phi=\hat\phi_1\circ\hat\phi_2$ at a point
$Q\in E'[N]$, the evaluator:
\begin{enumerate}
\item Computes $\Qmid=\hat\phi_2(Q)$,
\item Computes and publishes $s\Qmid$,
\item Finishes off the computation by computing
  $\hat\phi(Q)=\hat\phi_1(\Qmid)$.
\end{enumerate}
A watermark can then be verified by checking that
\[e_N^\mathrm{mid}(\phi_1(P),s\Qmid) = e_N'(s\phi(P),Q).\]
Interestingly, this proof is \emph{blind}, meaning that it can be
verified even before the work is finished.

Given $\hat\phi(Q)$, a usurper wanting to claim the computation for
themselves would need to either start from $Q$ and compute
$\hat\phi_2(Q)$, or start from $\hat\phi(Q)$ and compute
$\frac{\phi_1(\hat\phi(Q))}{\deg\phi_1}$. %
Either way, they would perform at least half as much work as if they
had legitimately evaluated the function.

As described here, it is possible, nevertheless, for a usurper to
target a specific evaluator, by generating a random $u\in\Z/N\Z$, and
choosing $us\phi_1(P)$ as public key. %
Then, any proof $s\Qmid$ for the legitimate evaluator is easily
transformed to a proof $us\Qmid$ for the usurper. %
This attack is easily countered by having all evaluators publish a
zero-knowledge proof of knowledge of their secret exponent $s$, along
with their public key $s\phi_1(P)$. %
Like in the previous section, this proof of knowledge of the secret
exponent can be replaced with an efficient non-zero-knowledge one
using pairings.


\section{Challenges in implementing isogeny-based delay functions}
\label{sec:secure-impl-isog}

For a delay function to be useful, there need to be convincing
arguments as to why the evaluation cannot be performed considerably
better than with the legitimate algorithm.

In this sense, repeated squaring modulo an RSA modulus is especially
appealing: modular arithmetic has been studied for a long time, and we
are reasonably confident that we know all useful algorithms and
hardware in this respect; and the repeated application of the function
$x\mapsto x^2$ is so simple that one may hope no better algorithm
exists (see\cite{BernsteinSorenson07}, though).

Repeated squaring in class groups, already, raises more skepticism, as
the arithmetic of class groups is a much less studied area. %
This clearly had an impact on Ethereum's choice to go with RSA-based
VDFs, despite class group based ones not needing a trusted setup.

For isogeny based delay functions, we argue that the degree of
assurance seems to be nearly as good as for RSA based ones, although
more research is certainly needed. %
To support this claim, we give here more details on the way the
evaluation of $\hat\psi$ is performed, that were omitted
by~\cite{10.1007/978-3-030-34578-5_10}.

For a start, we must choose a prime degree $\ell$. %
Intuitively, the smaller, the better, thus we shall fix $\ell=2$,
although $\ell=3$ also deserves to be studied. %
A $2$-isogeny is represented by rational maps of degree $2$, thus we
expect one isogeny evaluation to require at least one multiplication
modulo $p$. %
Our goal is to get as close as possible to this lower bound, by
choosing the best representation for the elliptic curves, their
points, and their isogenies.

It is customary in isogeny based cryptography to use curves in
Montgomery form, and projective points in $(X:Z)$ coordinates, as
these give the best formulas for arithmetic operations and
isogenies~\cite{costello2016sidh,10.1007/978-3-319-79063-3_11}. %
Montgomery curves satisfy the equation
\[E \;:\; y^2 = x^3 + Ax^2 + x,\] %
in particular they have a point of order two in $(0,0)$, and two other
points of order two with $x$-coordinates $\alpha$ and $1/\alpha$,
where $\alpha$ is a root of the polynomial $x^2+Ax+1$, and possibly
lives in $\F_{p^2}$. %
These three points define the three possible isogenies of degree $2$
starting from $E$. %
Montgomery form is almost unique, there being only three possible
choices for the $A$ coefficient for a given isomorphism class,
corresponding to the three possible choices for the point to send in
$(0,0)$.

In our case, all three points (in projective coordinates) $(0:1)$,
$(\alpha:1)$ and $(1:\alpha)$, are defined over $\F_p$, we thus choose
to distinguish one additional point by writing the curves as
\[E_\alpha \;:\; y^2 = x(x-\alpha)(x - 1/\alpha),\] %
with $\alpha\ne0,\pm 1$. %
We call this a \emph{semi-Montgomery form}; although it is technically
equivalent to the Montgomery form, $2$-isogeny formulas are expressed
in it more easily. %
Recovering the Montgomery form is easy via $A=-\alpha-1/\alpha$.

Using the formula of Renes~\cite{10.1007/978-3-319-79063-3_11}, we
readily get the isogeny with kernel generated by
$(\alpha:1)$ as
\begin{equation}
  \label{eq:isog-forward}
  \phi_\alpha(x,y) = \left(x\frac{x\alpha - 1}{x - \alpha}, \dots\right),
\end{equation}
and its image curve is the Montgomery curve defined by
$A = 2-4\alpha^2$. %
By comparing with the multiplication-by-$2$ map on $E_\alpha$, we
obtain the dual map to $\phi$ as
\begin{equation}
  \label{eq:isog-backward}
  \hat\phi_\alpha(x,y) = \left(\frac{(x+1)^2}{4\alpha x}, \dots\right).
\end{equation}
It is clear from this formula that the kernel of $\hat\phi_\alpha$ is
generated by $(0,0)$.

This formula is especially interesting, as we verify that its
projective version in $(X:Z)$ coordinates only requires $2$
multiplications and $1$ squaring:
\begin{equation}
  \label{eq:isog-proj}
  \hat\phi_\alpha(X:Z) = \bigl((X+Z)^2 : 4\alpha XZ\bigr),
\end{equation}
and the squaring can be performed in parallel with one
multiplication. %
The analogous formulas for $\phi_{1/\alpha}$ are readily obtained by
replacing $\alpha\to 1/\alpha$ in the previous ones, and moving around
projective coefficients to minimize work.

But, if we want to chain $2$-isogenies, we need a way to compute the
semi-Montgomery form of the image curve. %
For the given $A=4\alpha^2-2$, direct calculation shows that the two
possible choices are
\begin{equation}
  \label{eq:next-curve}
  \alpha' = 2\alpha\left(\alpha \pm \sqrt{\alpha^2 - 1}\right) - 1
  = \left(\alpha \pm \sqrt{\alpha^2-1})\right)^2.
\end{equation}
As we know that $(0,0)$ generates the dual isogeny to $\phi_\alpha$,
neither choice of $\alpha'$ will define a backtracking walk. %
Interestingly, Catryck and Decru~\cite{cryptoeprint:2019:1404} show
that when $p=7\mod 8$, if $\alpha\in\F_p$, $\phi_\alpha$ is a
horizontal isogeny (see definition in~\cite{cryptoeprint:2019:1404}),
and $\alpha'$ is defined as
\[\alpha' = \left(\alpha + \sqrt{\alpha^2-1})\right)^2\]
where $\sqrt{\alpha^2-1}$ denotes the principal square root, then
$\alpha'\in\F_p$ and $\phi_{\alpha'}$ is horizontal too. %
This gives a very simple algorithm to perform a non-backtracking
$2$-isogeny walk staying in the $\F_p$-restricted isogeny graph, i.e.,
a walk on the \emph{$2$-crater}. %
Alternatively, if a pseudo-random walk in the full supersingular graph
is wanted, one simply takes a random square root of $\alpha^2-1$.

Using these formulas, the isogeny walk $\phi:E\to E'$ is simply
represented by the list of coefficients $\alpha$ encountered, and the
evaluation of $\hat\phi$ using Formula~\eqref{eq:isog-proj} costs $2$
multiplications and $1$ parallel squaring per isogeny.

\subsubsection{Implementation challenges.}
Following the recommendations of~\cite{10.1007/978-3-030-34578-5_10},
for a 128-bits security level we need to choose a prime $p$ of around
$1500$ bits, which is comparable to the 2048-bits RSA arithmetic
targeted by Ethereum, although possibly open to optimizations for
special primes.

In software, the latency of multiplication modulo such a prime is
today around 1$\mu$s. %
The winner of the Ethereum FPGA competition~\cite{ethereum-vdf},
achieved a latency of 25ns for 2048-bits RSA arithmetic. %
Assuming a pessimistic baseline of 50ns for one $2$-isogeny
evaluation, for a target delay of $1$ hour we need an isogeny walk of length
$\approx 7\cdot 10^{10}$. %
That represents as many coefficients $\alpha$ to store, each occupying
$\approx 1500$ bits, i.e., $\approx 16$TiB of storage!

We stress that only evaluators need to store that much information,
however any FPGA design for isogeny-based delay functions must take
this constraint into account, and provide fast storage with
throughputs of the order of several GiB/s. %
% While such throughputs may be achieved by attaching several solid
% state drives in parallel, this solution may turn out to be unpractical
% and expensive.

If 2-isogenies can be evaluated in say 2ns then an isogeny VDF begins
consuming the full memory bandwidth of current CPUs, which conceivably
increases confidence in attackers computational limits. 

An isogeny-based VDF could dramatically reduce storage requirements by
doing repeated shorter evaluations, and simply hashing each output
to be the input for the next evaluation.  We sacrifice verifier time
by doing so, but verifiers remain fast since they still only compute
two or three pairings, depending upon watermarking.  We caution however
that this trick does not apply to Delay Encryption. 

In~\cite{10.1007/978-3-030-34578-5_10}, De Feo \emph{et al.} describe
an alternative implementation that divides the required storage by a
factor of $1244$, at the cost of slowing down evaluation by a factor
of at least $\log_2(1244)$. %
Unfortunately this trade-off seems unacceptable for applications where
the evaluator wants to get to the result as quickly as possible. %

It would be very interesting to find compact representations of very
long isogeny chains which do not come at the expense of efficiently
evaluating them.

\subsubsection{Optimality}
Formula~\eqref{eq:isog-proj} is, intuitively, almost optimal, as we
expect that a $2$-isogeny in projective $(X:Z)$ coordinates should
require at least $2$ multiplications. %
And indeed we know of at least one case where a $2$-isogeny can be
evaluated with $2$ parallel multiplications: the isogeny of kernel
$(0:1)$ is given by
\begin{equation}
  \label{eq:isog-special}
  \phi_0(x,y) = \left(\frac{(x - 1)^2}{x}, \dots\right),
\end{equation}
or, in projective coordinates,
\begin{equation}
  \label{eq:isog-special-proj}
  \phi_0(X:Z) = \bigl((X - Z)^2:XZ\bigr),
\end{equation}
which only requires one parallel multiplication and squaring.

We tried to construct elliptic curve models and isogeny formulas that
could evaluate $2$-isogeny chains using only $2$ parallel
multiplications per step, however any formula we could find had a
coefficient similar to $\alpha$ intervene in it, and thus bring the
cost up by at least one multiplication.

Intuitively, this is expected: there are exponentially many isogeny
walks, and the coefficients $\alpha$ must necessarily intervene in the
formulas to distinguish between them. %
However this is far from being a proof. %
Even proving a lower bound of $2$ \emph{parallel} multiplications
seems hard.

It would be interesting to prove that any $2$-isogeny chain needs at
least $2$ \emph{sequential} multiplications for evaluation, or
alternatively find a better way to represent and evaluate isogeny
chains.


\section{Conclusion}

We introduced a new time delay primitive, named Delay Encryption,
related to Time-lock Puzzles and Verifiable Delay Functions. %
Delay Encryption has some interesting applications such as sealed-bid
auctions and electronic voting. %
We gave an instantiation of Delay Encryption using isogenies of
supersingular curves and pairings, and discussed several related
topics that also apply to the VDF of De Feo, Masson, Petit and Sanso.

Several interesting questions are raised by our work. %
For example, while the security definition for Delay Encryption is
natural, we were not able to provide a meaningful security reduction
for our instantiation. %
It would be interesting to explore modifications to the scheme that
lead to a meaningful security proof.

Like the isogeny-based VDF, our Delay Encryption requires a trusted
setup. %
We described an efficient way to perform a distributed trusted setup,
however more research is needed on the zero-knowledge proofs used in
it.

The implementation of delay functions from isogenies presents several
practical challenges, such as needing very large storage for the
public parameters. %
On top of that, it is not evident how to prove the optimality of
isogenies formulas used for evaluating the delay function. %
While we gave here extremely efficient formulas, these seem to be at
least one multiplication more expensive than the theoretical
optimum. %
More research on the arithmetic of elliptic curves best adapted to
work with extremely long chains of isogenies is needed.

Finally, we invite the community to look for more constructions of
Delay Encryption, in particular quantum-resistant ones.

\def\doi#1{\href{https://doi.org/#1}{\tt https://doi.org/\nolinkurl{#1}}}
\bibliography{isovdf,zkp,isogenies_bib/isogenies}
\bibliographystyle{splncs04}

\end{document}

% LocalWords:  bilinear instantiation VDF subexponential morphisms
% LocalWords:  instantiations supersingular endomorphism morphism
% LocalWords:  isogenous homomomorphism endomorphisms homomorphism
% LocalWords:  isogenies Frobenius isogeny subgraphs distorsion
% LocalWords:  prover soundess sequentiality quaternion projective

